<h1 align="center">Computer Science</h1>
<h4 align="center">
    <p>
        <b>English</b> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_es.md">Español</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_fr.md">Français</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_bn.md">বাংলা</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ta.md">தமிழ்</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_guj.md">ગુજરાતી</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_pt.md">Portuguese</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_hi.md">हिंदी</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_te.md">తెలుగు</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ro.md">Română</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ar.md">العربية</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ar.md">简体中文</a>
    </p>
</h4>

## 贡献指南
如果你对于贡献这个项目感兴趣，请查看 [CONTRIBUTING.md](https://github.com/shhossain/computer_science/blob/main/CONTRIBUTING.md) 以了解如何对项目做出贡献。非常感谢你的贡献！

<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
[![All Contributors](https://img.shields.io/badge/all_contributors-139-orange.svg?style=flat-square)](#contributors-)
<!-- ALL-CONTRIBUTORS-BADGE:END -->


## 目录

- [介绍](#introduction)
- [电子计算机](#electronic-computer)
- [布尔逻辑](#boolean-logic)
- [数字系统](#number-systems)
- [中央处理器(CPU)](#central-processing-unit-cpu)
- [寄存器，缓存，和RAM](#registers-cache-and-ram)
- [指令和程序](#instructions-and-program)
- [编程语言](#programming-languages)
- [数据类型](#data-types)
- [声明和函数](#statements-and-functions)
- [数据结构](#data-structures)
- [算法](#algorithms)
- [艾伦·图灵](#alan-turing)
- [软件工程](#software-engineering)
- [集成电路](#integrated-circuits)
- [面向对象编程](#object-oriented-programming)
- [函数式编程](#functional-programming)
- [操作系统](#operating-systems)
- [内存和存储](#memory-and-storage)
- [文件系统](#file-system)
- [云计算](#cloud-computing)
- [机器学习](#machine-learning)
- [网络技术](#web-technology)
- [网络](#networking)
- [互联网](#internet)
- [DBMS(数据库管理系统)](#dbms)
- [密码学](#cryptography)
- [计算机理论](#theory-of-computation)


## 介绍

计算机科学是研究计算机和计算及其理论和实践应用的学科。计算机科学将数学、工程和逻辑的原理应用于众多问题。这些问题包括算法设计、软件/硬件开发以及人工智能。


## [电子计算机](Electronic%20Computer/readme.md)
电子计算机是一种计算设备，特别是一种执行高速数学或逻辑运算或组装、存储、相关或其他方式处理信息的可编程电子机器。

## [布尔逻辑](Boolean%20Logic/readme.md)
布尔逻辑是数学的一个分支，它处理真和假的值。它是一个逻辑系统，只使用两个值，0和1，分别代表假和真。它也被称为布尔代数，以1854年首次描述它的乔治布尔命名。

### 常见的布尔运算符
| 运算符 | 名称 |               描述               |
| :------: | :--: | :-------------------------------------: |
|    !     | 非  |    取操作数的非。    |
|    &&    | 与  | 如果两个操作数都为真则返回 **true**。 |
|   \|\|   |  或  | 如果一个或所有操作数为真则返回 **true**。 |

### 应该了解的布尔运算符
| 运算符 | 名称 |               描述               |
| :------: | :--: | :-------------------------------------: |
|    ()    | 括号     |   允许你分组关键词并控制搜索的顺序。    |
|    “”    | 引号 | 提供精确短语的结果。 |
|   *      |  星号       | 提供包含关键词变体的结果。 |
|   ⊕     |  异或            | 如果操作数不同则返回 **true** |
|   ⊽      |  或非            | 如果所有操作数为假则返回 **true**。 |
|   ⊼      |  与非           | 只有当其两个输入的值都为真时才返回 **false**。 |

## [数字系统](Number%20System/readme.md#number-systems)
数字系统是表达数字的数学系统。数字系统由一组用来表示数字的符号和一组用来处理这些符号的规则组成。数字系统中使用的符号被称为数字符号。

### [数字系统的类型](Number%20System/readme.md#types-of-number-systems)
- [位置数字符号系统](Number%20System/readme.md#positional-numeral-system)
- [符号-值记数系统](Number%20System/readme.md#sign-value-notation-system)

### [常见的位置数字系统](Number%20System/readme.md#common-positional-number-systems)
- [二进制](Number%20System/readme.md#binary)
- [八进制](Number%20System/readme.md#octal)
- [十进制](Number%20System/readme.md#decimal)
- [十六进制](Number%20System/readme.md#hexadecimal)


### 二进制的重要性
二进制是由莱布尼茨发明的一个由0和1两个数字或字符组成的系统。这个数字系统是所有二进制代码的基础，这些代码被用来编写数码数据，例如每天使用的计算机处理器指令。在二进制中，0和1分别代表OFF或ON。在一个晶体管中， "0"代表没有电流流动， "1"代表电流被允许流动。以这种方式，数字被物理地表示在计算设备内部，允许进行计算。

二进制仍然是计算机的主要语言，以下是其在电子和计算机硬件中的应用原因：

- 它是一个简单而优雅的设计。
- 二进制的0和1方法快速检测电信号的关闭（false）或打开（true）状态。
- 只有两个状态的电信号使其更不易受到电磁干扰。
- 磁介质的正负极快速转换为二进制。
- 二进制是控制逻辑电路的最有效方式。

# [中央处理器 (CPU)](CPU/readme.md#central-processing-unitcpu)
中央处理器（CPU）是所有计算机中最重要的部分。CPU通过发送信号来控制计算机的其他部分，就像大脑控制身体一样。CPU会根据一份要做的计算机工作列表，也就是指令，进行工作。它读取指令列表并按顺序运行（执行）每一条指令。CPU可以运行的指令列表就是一个计算机程序。CPU可以在称为"核心"的部分同时处理多条指令。一个有四个核心的CPU可以一次处理四个程序。CPU本身主要由三个主要组件组成，它们是：
1. [内存或存储单位](CPU/readme.md#memory-or-storage-unit)
2. [控制单元](CPU/readme.md#control-unit)
3. [算术和逻辑单元 (ALU)](CPU/readme.md#arithmetic-and-logic-unit-alu)


## [寄存器，高速缓存和RAM](/Registers%20Cache%20and%20RAM)

### [寄存器](/Registers%20Cache%20and%20RAM/readme.md#register)
寄存器是CPU内部包含的少量高速存储器。寄存器是一个由"触发器"（用于存储1位内存的电路）组成的集合。它们被处理器用来存储在处理过程中需要的少量数据。一个CPU可能有几套称为"核心"的寄存器。寄存器还有助于进行算术和逻辑操作。

算术操作是CPU对存储在寄存器中的数值数据进行的数学计算。这些操作包括加法、减法、乘法和除法。逻辑操作是CPU对存储在寄存器中的二进制数据进行的布尔计算。这些操作包括比较（例如，测试两个值是否相等）和逻辑操作（例如，AND，OR，NOT）。

寄存器对于执行这些操作至关重要，因为它们允许CPU快速访问和处理少量数据。通过在寄存器中存储频繁访问的数据，CPU可以避免从内存中检索数据的慢速过程。

更大量的数据可能存储在高速缓存中，这是一种处理速度非常快的存储器，位于与寄存器相同的集成电路上。高速缓存用于存储程序运行时频繁访问的数据。更大量的数据可能存储在RAM中。RAM是随机访问存储器的简称，这种存储器用于保存从磁盘存储中移动的数据和指令，直到处理器需要这些数据和指令时才会使用。


### [高速缓存](/Registers%20Cache%20and%20RAM/readme.md#cache)
高速缓存内存是一种基于芯片的计算机组件，可以使从计算机内存中检索数据更加高效。它充当一个临时存储区，使计算机的处理器可以轻松检索数据。这个被称为高速缓存的临时存储区对处理器来说比计算机的主内存源（通常是某种形式的DRAM）更容易获得。

高速缓存内存有时被称为CPU（中央处理单元）内存，因为它通常直接集成在CPU芯片中，或者放在一个有与CPU单独总线互连的独立芯片上。因此，它对处理器更容易获得，能够提高效率，因为它物理上离处理器更近。

为了靠近处理器，高速缓存内存需要比主内存小得多。因此，它的存储空间更小。它也比主内存更贵，因为它是一个更复杂且性能更强大的芯片

在大小和价格上的牺牲，它在速度上得到了补偿。高速缓存内存的运行速度比RAM快10到100倍，只需要几纳秒就能响应CPU的请求。

用于高速缓存内存的实际硬件的名字是高速静态随机访问存储器(SRAM)。用于计算机主存储器的硬件的名字是动态随机访问存储器(DRAM)。

高速缓存内存不应与更广义的术语高速缓存混淆。高速缓存是临时数据存储，可以在硬件和软件中存在。高速缓存内存指的是允许计算机在网络的各个层次创建高速缓存的特定硬件组件。高速缓存是用于在计算环境中临时存储某物（通常是数据）的硬件或软件。

### [RAM](/Registers%20Cache%20and%20RAM/readme.md#ram)
RAM（随机存取存储器）是一种计算机存储器，可以按任意顺序读取和更改，通常用于存储工作数据和机器代码。随机存取存储器设备允许数据项在几乎相同的时间内被读取或写入，无论数据在内存内的物理位置如何，这与其他直接访问数据存储媒体（如硬盘、CD-RW、DVD-RW和旧式的磁带和磁鼓存储器）形成了鲜明的对比，后者读取和写入数据项所需的时间根据其在记录介质上的物理位置的不同而显著不同，这是由于机械限制（如媒体旋转速度和悬臂移动）。

## [指令和程序](Not-Added)
在计算机科学中，指令是由处理器指令集定义的处理器的单个操作。计算机程序是一系列指令，告诉计算机要做什么。计算机做的每一件事都是通过使用计算机程序来完成的。存储在计算机内存中的程序（"内部编程"）让计算机可以一个接一个地完成任务，虽然中间可能有停顿。

## [编程语言](/Programming_Languages/readme.md)
编程语言是一种规则集，可以将字符串，或者在可视化编程语言中的图形程序元素转换为各种类型的机器代码输出。编程语言是用于计算机编程以实现算法的一种计算机语言。

编程语言通常分为两大类：
1. 高级语言使用与英语类似的语法。源代码使用编译器或解释器转换为机器可理解的机器代码。Java和Python是一些高级编程语言的例子。这些语言的执行速度通常比低级语言慢，但更容易使用。
2. 低级编程语言与硬件更紧密地协作，并对其有更多的控制。它们直接与硬件交互。机器语言和汇编语言是两个常见的低级语言的例子。这些语言通常比高级语言快，但是它们的可读性差，使用起来非常困难。

### [编程范式](/Programming_Languages/readme.md#Programming+Paradigms)
还有几种不同的*编程范式*。编程范式是给定程序或编程语言可以组织的不同方式或风格。每一种范式都包含了一些结构、特性和对如何解决常见编程问题的观点。

编程范式并*不是*语言或工具。你不能用范式来"构建"任何东西。它们更像是一套许多人已经达成一致、遵循并扩展的理想和指导方针。编程语言并不总是与特定的范式相关联。*确实有*一些语言是以某种特定的范式为思路构建的，并且具有比其他语言更能促进那种编程的特性（Haskell和函数式编程就是一个很好的例子）。但也有"多范式"的语言，你可以在其中调整你的代码以适应某种范式或者其他范式（JavaScript和Python就是很好的例子）。

## [数据类型](Data%20Types/readme.md#data-types)
在编程中，数据类型是一种分类，它指定了一个变量具有哪种类型的值，以及可以对它应用哪种类型的数学、关系或逻辑操作，而不会引起错误。

### [基本数据类型](Data%20Types/readme.md#primitive-data-types)
基本数据类型是编程语言中最基本的数据类型。它们是更复杂数据类型的构建块。基本数据类型是由编程语言预定义的，并由保留关键词命名。

### [常见的基本数据类型](Data%20Types/readme.md#common-primitive-data-types)
- [整数](Data%20Types/readme.md#integer)
- [浮点数](Data%20Types/readme.md#float)
- [布尔值](Data%20Types/readme.md#boolean)
- [字符](Data%20Types/readme.md#character)
- [字符串](Data%20Types/readme.md#string)

### [非基本数据类型](Data%20Types/readme.md#non-primitive-data-types)
非基本数据类型也被称为引用数据类型。它们是由程序员创建的，并没有被编程语言定义。非基本数据类型也被称为复合数据类型，因为它们是由其他类型组成的。

### [常见的非基本数据类型](Data%20Types/readme.md#common-non-primitive-data-types)
- [数组](Data%20Types/readme.md#array)
- [结构体](Data%20Types/readme.md#struct)
- [集合](Data%20Types/readme.md#union)
- [指针](Data%20Types/readme.md#pointer)
- [函数](Data%20Types/readme.md#function)
- [类](Data%20Types/readme.md#class)

## [语句和函数](Statements%20and%20Functions/readme.md)
在计算机编程中，语句是命令式编程语言的一个语法单位，表示要执行的某个动作。用这种语言编写的程序由一个或多个语句的序列组成。语句可能有内部组件（例如，表达式）。
在任何编程语言中，有两种主要的语句类型，这些语句对构建代码的逻辑是必要的。

1. [条件语句](Statements%20and%20Functions/readme.md#conditional-statements)

    主要有两种类型的条件语句：
    - if
    - if-else
    - switch case


2. [循环](Statements%20and%20Functions/readme.md#loops)

    主要有三种类型的条件语句：
    - for循环
    - while循环
    - do - while循环 (while循环的一种变形)
    - do - until循环

------------

函数是执行特定任务的语句块。函数接收数据，处理数据，并返回结果或执行之。函数主要是为了支持可重用性的概念。一旦写好一个函数，就可以轻松地调用它，而无需重复相同的代码。

不同的函数式语言使用不同的语法来编写函数。

在[这里](Statements%20and%20Functions/readme.md#functions)阅读更多关于函数的信息。

## [数据结构](Data%20Structures/readme.md)
在计算机科学中，数据结构是一种便于对数据进行增删改查等操作的存储格式。更准确地说，数据结构是一个数据的集合，数据之间的关系和可以应用于数据的函数或操作。

### 数据结构的类型
- [数组](Data%20Structures/readme.md#array)
- [链表](Data%20Structures/readme.md#linkedlist)
- [栈](Data%20Structures/readme.md#stack)
- [队列](Data%20Structures/readme.md#queue)
- [哈希表](Data%20Structures/readme.md#hashtable)
- [堆](Data%20Structures/readme.md#heap)
- [树](Data%20Structures/readme.md#tree)
- [图](Data%20Structures/readme.md#graph)

## [算法](Algorithms/readme.md)
算法是完成计算所必需的一系列步骤。它们是我们设备所做的事情的核心，这并不是一个新名词。自从数学本身的发展以来，我们就需要算法来帮助我们更高效地完成任务，但是今天我们将看一看一些现代计算问题，如排序和图搜索，展示我们如何使它们更高效，以便你可以更容易地找到廉价的机票，或者找到去冬堡或某个餐馆的路线图。

### [时间复杂度](Algorithms/Time%20Complexity/readme.md)
算法的时间复杂度估计了算法对于某个输入将使用多少时间。这个概念是将效率表示为一个函数，其参数是输入的大小。通过计算时间复杂度，我们可以在不实现算法的情况下确定算法是否足够快。

### [空间复杂度](Algorithms/Space%20Complexity/readme.md)
空间复杂度指的是算法/程序使用的总内存空间，包括执行输入值所占用的空间。确定空间复杂度，需要计算算法/程序中变量所占用的空间。

### [排序](Algorithms/Sorting/readme.md)
排序是将一系列项目按照特定顺序排列的过程。例如，如果你有一份名字的列表，你可能希望按字母顺序进行排序。或者，如果你有一份数字的列表，你可能希望按从小到大的顺序进行排序。排序是一个常见的任务，我们有许多不同的方式来完成它。

### [搜索](Algorithms/Searching/readme.md)
搜索是在一个数据集合内查找某个目标元素的算法。搜索算法被设计用来检查一个元素或从它所存储的任何数据结构中检索一个元素。

## [基于字符串的算法](Algorithms/String%20Based%20Algorithms/readme.md)
字符串是编程中最常用和最重要的数据结构之一，本仓库包含了一些最常用的算法，这些算法可以帮助我们提高搜索速度，提升我们的代码。

### [图搜索](Algorithms/Graph/readme.md)
图搜索是通过图来寻找特定节点的过程。图是一种数据结构，由有限的（可能可变的）顶点或节点或点，以及这些顶点的无序对（对于无向图）或有序对（对于有向图）组成。这些对被称为边、弧或线（对于无向图），或箭头、有向边、有向弧或有向线（对于有向图）。顶点可能是图结构的一部分，也可能是由整数索引或引用表示的外部实体。图是许多现实世界应用的最有用的数据结构之一。图用于模拟对象之间的成对关系。例如，航线网络是一个图，城市是顶点，航班路线是边。图也被用来表示网络。互联网可以被视为一个图，计算机是顶点，计算机之间的链接是边。图也被用在LinkedIn和Facebook等社交网络上。图被用来表示许多现实世界的应用：计算机网络、电路设计和航空调度等。

### [动态规划](Algorithms/Dynamic%20Programming/README.md)
动态规划既是一种数学优化方法，也是一种计算机编程方法。理查德·贝尔曼在20世纪50年代开发了这种方法，已在航空航天工程、经济学等众多领域中找到应用。在两个语境中，它都是指通过递归的方式将一个复杂问题简化为更简单的子问题。尽管有些决策问题无法用这种方式拆解，但跨越多个时间点的决策往往可以递归地拆解。同样，在计算机科学中，如果一个问题可以通过将其拆解为子问题，然后递归地找到子问题的最优解来解决，那么它就被认为具有最优子结构。动态规划是一种解决这些性质问题的方式。将一个复杂问题拆解为更简单的子问题的过程被称为"分治"。

### [贪心算法](Algorithms/Greedy%20Algorithm/readme.md)
贪心算法是一种简单、直观的算法类，可以用来找到一些优化问题的最优解。它们被称为贪心算法，因为在每一步，它们都做出了当时看起来最好的选择。这意味着贪心算法不能保证返回全局最优解，而是在希望找到全局最优解的过程中做出局部最优的选择。贪心算法被用于优化问题。一个优化问题可以使用贪心算法来解决，如果这个问题具有以下性质：在每一步，我们都可以做出当前看起来最好的选择，然后我们就能得到完整问题的最优解。

### [回溯](Algorithms/Backtracking/README.md)
回溯是一种算法技术，通过尝试逐步建立解决方案，一次一个部分，移除那些在任何时间点（这里的时间指的是到达搜索树的任何级别所经过的时间）无法满足问题约

### [不同搜索和排序算法的时间复杂度和空间复杂度](Not-Added)
**时间复杂度**：它被定义为预期执行特定指令集的次数，而不是总共花费的时间。由于时间是一个依赖现象，时间复杂度可能会因一些外部因素（如处理器速度，使用的编译器等）而变化。

**空间复杂度**：它是程序执行所消耗的总内存空间。

两者都被计算为输入大小(n)的函数。算法的时间复杂度以大O表示法表示。

算法的效率依赖于这两个参数。

时间复杂度的类型：

- *最佳时间复杂度*：算法花费的时间最少或最少的输入。在最佳情况下，我们计算算法的下界时间复杂度。例如：如果要搜索的数据位于线性搜索中的大型数据数组的第一个位置，那么最佳情况就发生了。
- *平均时间复杂度*：我们取所有随机输入并计算所有输入的计算时间。然后，我们将其除以输入的总数。
- *最坏时间复杂度*：定义算法花费的时间最长或最大的输入。在最坏的情况下，我们计算算法的上界。例如：如果要搜索的数据位于线性搜索算法中的大型数据数组的最后位置，那么最坏情况就会发生。

一些常见的时间复杂度是：

- **O(1)**：这表示常数时间。 O(1)通常意味着算法将具有常数时间，无论输入大小如何。哈希图是常数时间的完美例子。

- **O(log n)**：表示对数时间。 O(log n)表示对于每个操作实例，性能都会降低。在二叉搜索树(BSTs)中搜索元素是对数时间的一个很好的例子。

- **O(n)**：表示线性时间。 O(n)意味着性能与输入大小直接成正比。简单地说，输入的数量和执行这些输入所需的时间将成正比。数组中的线性搜索是线性时间复杂度的一个很好的例子。

- **O(n*n)**：表示二次方时间。 O(n^2)意味着性能直接与输入的平方成正比。简单来说，执行所需的时间大致是输入大小的平方倍。嵌套循环是二次方时间复杂度的绝佳例子。

- **O(n log n)**：表示多项式时间复杂度。 O(n log n)意味着性能是O(log n)的n倍，（这是最坏情况下的复杂度）。一个好的例子是分而治之的算法，比如归并排序。这种算法首先分割集合，这需要O(log n)的时间，然后征服并通过集合进行排序，这需要O(n)的时间-因此，归并排序需要O(n log n)的时间。

| 算法	        |             |  时间复杂度    |	       | 空间复杂度  |
|   :---:        |  :---:      |  :---: 	       |   :---: 	   |   :---:      |
|  	             | 最佳	       | 平均	       |  最坏	     |  最坏        |
| 选择排序       | Ω(n^2)	     | θ(n^2)	       | O(n^2)	     | O(1)         |
| 冒泡排序	     | Ω(n)	       | θ(n^2)	       | O(n^2)	     | O(1)         |
| 插入排序       | Ω(n)	       | θ(n^2)	       | O(n^2)	     | O(1)         |
| 堆排序	     | Ω(n log(n)) | θ(n log(n))   | O(n log(n)) | O(1)         |
| 快速排序	     | Ω(n log(n)) | θ(n log(n))   | O(n^2)	     | O(n)         |
| 归并排序	     | Ω(n log(n)) | θ(n log(n))   | O(n log(n)) | O(n)         |
| 桶排序         | Ω(n +k)	   | θ(n +k)	   | O(n^2)	     | O(n)         |
| 基数排序  	 | Ω(nk)	     | θ(nk)	       | O(nk)	     | O(n + k)     |
| 计数排序  	 | Ω(n +k)	   | θ(n +k)	   | O(n +k)	   | O(k)         |
| 希尔排序  	 | Ω(n log(n)) | θ(n log(n))   | O(n^2)	     | O(1)         |
| Tim 排序	     | Ω(n)	       | θ(n log(n))   | O(n log(n)) | O(n)         |
| 树排序       	 | Ω(n log(n)) | θ(n log(n))   | O(n^2)	     | O(n)         |
| 立方排序	     | Ω(n)	       | θ(n log(n))   | O(n log(n)) | O(n)         |


| 算法	     |             |  时间复杂度    |
|   :---:    |  :---:      |  :---: 	  |   
|  	         | 最佳	       | 平均	         |  最坏	     |
| 线性搜索   | O(1)	       | O(N)	         | O(N)	     |
| 二分搜索	 | O(1)	       | O(logN)       | O(logN)	   |


## [艾伦·图灵](Not-Added)
艾伦·图灵（1912年6月23日伦敦出生，1954年6月7日在威尔姆斯洛，柴郡逝世）是一位英国数学家和逻辑学家。他在剑桥大学和普林斯顿高级研究所学习。在他具有里程碑意义的1936年的论文《关于可计算数》中，他证明了不能存在任何通用的算法方法来确定数学中的真理，并且数学将总是包含不可决定的（相对于未知的）命题。那篇论文也引入了图灵机。他相信计算机最终将能够进行与人类无法区分的思考，并提出了一个简单的测试（见图灵测试）来评估这种能力。他关于这个主题的论文被广泛承认为人工智能研究的基础。他在二战期间在密码学方面做出了宝贵的工作，对破解德国用于无线电通信的谜机密码起到了重要作用。战后，他在曼彻斯特大学任教，并开始研究现在称为人工智能的东西。在这个开创性的工作中，图灵被发现在床上死亡，死因是氰化物中毒。他的死亡是在被捕进行同性恋行为（当时是犯罪）并被判处12个月的荷尔蒙疗法之后。

2009年的一场公众运动之后，英国首相戈登·布朗代表英国政府正式公开道歉，为他们对图灵的惨酷待遇表示歉意。英女王伊丽莎白二世在2013年赦免了他的罪。"艾伦·图灵法"现在被非正式地用来指2017年在英国的一项法律，该法律追溯地赦免了在历史上将同性恋行为定为非法的男性。

图灵的影响深远，有许多雕像和许多以他的名字命名的事物，包括一个针对计算机科学创新的年度奖项。他出现在现行的英格兰银行50英镑纸币上，该纸币于2021年6月23日（与他的生日相吻合）发布。在2019年BBC系列节目中，经过观众投票，他被誉为20世纪最伟大的人。

## [软件工程](Software%20Engineering/readme.md)
软件工程是计算机科学的一个分支，它处理软件应用的设计、开发、测试和维护。软件工程师应用工程原理和编程语言知识来构建面向最终用户的软件解决方案。

让我们来看看软件工程的各种定义：

- IEEE在其610.12-1990标准中，将软件工程定义为一个系统化、有纪律、可计算的方法，用于软件的开发、操作和维护。
- Fritz Bauer将其定义为'建立和使用标准工程原则。它帮助你获得经济、可靠并在实际机器上高效工作的软件。
- Boehm将软件工程定义为涉及'将科学知识实际应用到计算机程序的创造性设计和构建。它还包括开发、操作和维护它们所需的相关文档。'

### 软件工程师的任务和职责
成功的工程师知道如何使用正确的编程语言、平台和架构来开发从电脑游戏到网络控制系统的所有东西。除了建立他们自己的系统，软件工程师还测试、改进和维护其他工程师构建的软件。

在这个角色中，你的日常任务可能包括以下内容：

- 设计和维护软件系统
- 评估和测试新的软件程序
- 优化软件以提高速度和可扩展性
- 编写和测试代码
- 与客户、工程师、安全专家以及其他相关人员进行咨询
- 向利益相关者和内部客户展示新功能

### 软件工程的阶段
软件工程过程涉及到几个阶段，包括需求收集、设计、实现、测试和维护。通过遵循规范的软件开发方法，软件工程师可以创建出高质量的软件，满足用户的需求。

- 软件工程的第一阶段是需求收集。在这个阶段，软件工程师与客户合作确定软件的功能需求和非功能需求。功能需求描述了软件应该做什么，而非功能需求描述了它应该如何做。需求收集是一个关键的阶段，因为它为整个软件开发过程奠定了基础。

- 在需求收集之后，下一个阶段是设计。在这个阶段，软件工程师为软件的架构和功能创建一个详细的计划。这个计划包括一个软件设计文档，指定了软件的结构、行为和与其他系统的交互。软件设计文档是非常重要的，因为它作为实现阶段的蓝图。

- 实现阶段是软件工程师为软件创建实际代码的地方。这是将设计文档转化为工作软件的地方。实现阶段涉及到编写代码、编译代码，并测试它以确保它满足设计文档中指定的需求。

- 在软件工程中，测试是一个关键的阶段。在这个阶段，软件工程师检查以确保软件运行正确、可靠并且易于使用。这涉及到几种类型的测试，包括单元测试、集成测试和系统测试。测试确保软件满足需求并按预期运行。

- 软件工程的最后阶段是维护。在这个阶段，软件工程师对软件进行更改，以纠正错误、添加新功能或改善其性能。维护是一个持续的过程，贯穿于软件的整个生命周期。

### 为什么软件工程如此流行？

- 计算机科学：为软件提供科学基础，就像电气工程主要依赖物理学一样。
- 管理科学：软件工程是劳动密集型的，需要技术和管理控制。因此，它在管理科学中被广泛使用。
- 经济学：在这个领域，软件工程帮助你估计资源和控制成本。必须开发计算系统，并且数据应在给定的预算内定期维护。
- 系统工程：大多数软件都是一个更大系统的组成部分。例如，工业监控系统中的软件或飞机上的飞行软件。应该将软件工程方法应用于这种类型的系统的研究。

## [集成电路](Integrated%20Circuits/readme.md)
集成电路或者硅片集成电路（也被称为IC，芯片，或者微芯片）是一套电子电路集成在一小块扁平的半导体材料（或"芯片"）上，通常是硅。许多微小的MOSFETs（金属-氧化物-半导体场效应晶体管）集成在一个小芯片上。这导致电路比由离散电子元件构成的电路小了几个数量级，更快，也更便宜。IC的大规模生产能力，可靠性，和集成电路设计的积木式方法，确保了标准化ICs代替离散晶体管的快速采用。ICs现在被用于几乎所有的电子设备，并且已经革新了电子世界。电脑，手机，和其他家用电器现在已经成为现代社会结构不可或缺的部分，这得益于ICs的小尺寸和低成本，比如现代计算机处理器和微控制器。

超大规模集成电路被金属-氧化物-硅（MOS）半导体器件制造的技术进步变得实际可行。自从它们在1960年代起源以来，芯片的大小，速度，和容量已经取得了巨大的进步，受到技术进步的驱动，可以在相同大小的芯片上装更多的MOS晶体管 – 现代的芯片可能在人指甲大小的区域里有多达几十亿的MOS晶体管。这些进步遵循着摩尔定律，使得今天的计算机芯片相比于1970年代初期的芯片具有几百万倍的容量和几千倍的速度。

ICs相比离散电路有两个主要的优势：成本和性能。成本低是因为芯片，和它们所有的组件，作为一个单位通过光刻技术打印，而不是一个一个晶体管地构造。此外，封装的ICs比离散电路使用的材料少得多。性能很高，因为IC的组件切换速度快、体积和间距都相对较小，因此消耗的电力相对较少。ICs的主要缺点是设计它们和制作所需的光罩的高成本。这种高初始成本意味着只有当预期有高产量时，ICs才在商业上具有可行性。

### 类型
现代电子元件分销商通常会进一步对集成电路进行子分类：

- 数字IC被分类为逻辑IC（如微处理器和微控制器）、存储芯片（如MOS存储器和浮动栅存储器）、接口IC（电平转换器，串行器/解串行器等）、电源管理IC和可编程设备。
- 模拟IC被分类为线性集成电路和射频电路（无线电频率电路）。
- 混合信号集成电路被分类为数据采集IC（A/D转换器，D/A转换器和数字电位计），时钟/计时IC，开关电容（SC）电路和RF CMOS电路。
- 三维集成电路（3D ICs）被分类为硅通孔IC（TSV）和铜-铜连接IC。

## [面向对象编程](Object%20Oriented%20Programming/readme.md)
面向对象编程是一种基于对象和数据概念的基本编程范式。

它是每个程序员都必须遵守的编码标准方式，以便更好地阅读和重用代码。

### * 面向对象编程有四个基本概念:
- 抽象
- 封装
- 继承
- 多态

了解更多关于OOP的概念[在这里](Object%20Oriented%20Programming/readme.md)

## [函数式编程](Functional%20Programming/readme.md)

在计算机科学中，函数式编程是一种编程范式，程序是通过应用和组合函数构建的。它是一种声明式的编程范式，其中函数定义是表达式的树，将值映射到其他值，而不是一系列改变程序运行状态的命令式语句。

在函数式编程中，函数被视为一等公民，这意味着它们可以被绑定到名称（包括局部标识符），作为参数传递，从其他函数返回，就像任何其他数据类型一样。这允许程序以声明式和组合式的风格编写，其中小函数以模块化的方式组合在一起。

函数式编程有时被视为纯函数式编程的同义词，纯函数式编程是函数式编程的一个子集，它将所有函数视为确定性的数学函数，或纯函数。当用一些给定的参数调用纯函数时，它总是返回相同的结果，并且不能受到任何可变状态或其他副作用的影响。这与非纯过程形成鲜明对比，非纯过程在命令式编程中很常见，它可以有副作用（例如修改程序的状态或从用户获取输入）。纯函数式编程的支持者声称，通过限制副作用，程序可以有更少的错误，更容易调试和测试，并且更适合于正式的验证程序。

函数式编程起源于学术界，从λ演算演变而来，λ演算是一种只基于函数的计算的形式系统。从历史角度来看，函数式编程没有命令式编程流行，但是现在函数式编程开始应用于在工业和教育中。

函数式编程语言的一些例子包括：
- <a href="https://lisp-lang.org/"> Common Lisp </a>
- <a href="https://www.scheme.org/"> Scheme </a>
- <a href="https://racket-lang.org/"> Racket </a>
- <a href="https://www.erlang.org/"> Erlang </a>
- <a href="https://www.haskell.org/"> Haskell </a>
- <a href="https://fsharp.org/"> F# </a>
- <a href="https://cs.lmu.edu/~ray/notes/introml/"> ML </a> 

函数式编程历史上源自*λ演算*。λ演算是由阿隆佐·丘奇开发的一个框架，用于研究函数的计算。它常被称为"世界上最小的编程语言"。它提供了可计算和不可计算的定义。它在计算能力上等价于图灵机，λ演算可以计算的任何东西，就像图灵机可以计算的任何东西一样，是可计算的。它为描述函数及其求值提供了一个理论框架。

函数式编程的一些基本概念包括：
- 纯函数 
- 递归
- 引用透明性
- 函数作为一等公民和高阶函数
- 变量是不可变的。

**纯函数**：这些函数有两个主要属性。首先，它们总是为相同的参数产生相同的输出，而不考虑任何其他因素。其次，它们没有副作用。即它们不修改任何参数或局部/全局变量或输入/输出流。后者的属性被称为*不可变性*。纯函数唯一的结果就是它返回的值。它们是决定性的。使用函数式编程完成的程序易于调试，因为它们没有副作用或隐藏的I/O。纯函数也使编写并行/并发应用程序变得更容易。当代码以这种风格编写时，智能编译器可以做很多事情-它可以并行化指令，等待评估结果直到需要，以及记住结果，因为只要输入不变，结果就永远不会变。下面是Python中的一个简单的纯函数示例：

```python
def sum(x ,y): # sum是一个以x和y为参数的函数
    return x + y  # 返回x + y而不改变值
 ```

**递归**：在纯函数式编程语言中没有"for"或"while"循环。迭代是通过递归实现的。递归函数反复调用自己，直到达到基本情况。下面是一个简单的C语言递归函数示例：

```c
int fib(n) {
  if(n <= 1)
    return 1;
   else
     return (fib(n-1) + fib(n-2));
}
 ```

 **引用透明**：在函数式程序中，一旦定义的变量在整个程序中不会改变其值。函数式程序没有赋值语句。如果我们需要存储某个值，我们会定义一个新的变量，而不是改变已有的变量。这消除了任何副作用的可能性，因为任何变量都可以在执行的任何时刻被其实际值替换。任何变量在任何时刻的状态都是恒定的。例如：

```bash
x = x + 1 # 这改变了变量x赋值的值
         # 因此，这个表达式不是引用透明的
```

**函数是一等公民并且可以是高阶的**：一等函数被视为一等变量。一等变量可以作为参数传递给函数，可以从函数返回或存储在数据结构中。

可以使用一个叫做**funcall**的LISP形式来定义函数应用的组合，它将一个函数和一系列的参数作为参数，并将该函数应用于这些参数：

```Lisp
(defun filter (list-of-elements test)
    (cond ((null list-of-elements) nil)
          ((funcall test (car list-of-elements))
            (cons (car list-of-elements)
                (filter (cdr list-of-elements)
                      test)))
           (t (filter (cdr list-of-elements)
                       test))))
   ```
**filter**函数将测试应用于列表的第一个元素。如果测试返回非空，它将元素连到filter应用于列表cdr的结果上；否则，它只返回过滤后的cdr。这个函数可以与作为参数传入的不同谓词一起使用，执行各种过滤任务，下面是两个示例：

```Lisp
    > (filter '(1 3 -9 5 -2 -7 6) #'plusp)   ; 过滤掉所有的负数 
```    
    输出：(1 3 5 6)

```Lisp
   > (filter '(1 2 3 4 5 6 7 8 9) #'evenp)   ; 过滤掉所有的奇数
```   
   输出：(2 4 6 8)

**变量是不可变的**：在函数式编程中，我们不能修改一个已初始化的变量。我们可以创建新的变量-但我们不能修改现有的变量，这对于在程序运行过程中维护状态非常有帮助。一旦我们创建一个变量并设置其值，我们可以充分确信该变量的值永远不会改变。

## [操作系统](Operating%20Systems/readme.md)
操作系统（或简称为OS）充当计算机用户和计算机硬件之间的中介。操作系统的目的是提供一个环境，用户可以在其中方便、高效地执行程序。
操作系统是管理计算机硬件的软件。硬件必须提供适当的机制来确保计算机系统的正确操作，并防止用户程序干扰系统的正常运行。
更常见的定义是，操作系统是计算机上始终运行的一个程序（通常称为内核），所有其他的都是应用程序。

操作系统可以从两个观点来看：资源管理器和扩展机。在资源管理器视图中，操作系统的任务是有效地管理系统的不同部分。在扩展机视图中，系统的工作是为用户提供比实际机器更方便使用的抽象。这些抽象包括进程、地址空间和文件。操作系统有着悠久的历史，从它们取代操作员到现代的多程序系统。重要的里程碑包括早期的批处理系统、多程序系统和个人计算机系统。由于操作系统与硬件紧密交互，一些计算机硬件的知识对于理解操作系统是有用的。计算机是由处理器、内存和I/O设备组成的。这些部分通过总线连接。所有操作系统都是基于进程、内存管理、I/O管理、文件系统和安全性的基本概念构建的。任何操作系统的核心是它可以处理的系统调用集。这些告诉我们操作系统做什么。
